jenkins:
  # Default values for jenkins.
  # This is a YAML-formatted file.
  # Declare name/value pairs to be passed into your templates.
  # name: value

  ## Overrides for generated resource names
  # See templates/_helpers.tpl
  # nameOverride:
  # fullnameOverride:
  # namespaceOverride:

  # For FQDN resolving of the controller service. Change this value to match your existing configuration.
  # ref: https://github.com/kubernetes/dns/blob/master/docs/specification.md
  clusterZone: "cluster.local"

  renderHelmLabels: true

  controller:
    # Used for label app.kubernetes.io/component
    componentName: "jenkins-controller"
    image: "jenkins/jenkins"
    # tag: "2.375.2-jdk11"
    tagLabel: jdk11
    imagePullPolicy: "Always"
    imagePullSecretName:
    # Optionally configure lifetime for controller-container
    lifecycle:
    #  postStart:
    #    exec:
    #      command:
    #      - "uname"
    #      - "-a"
    disableRememberMe: false
    numExecutors: 0
    # configures the executor mode of the Jenkins node. Possible values are: NORMAL or EXCLUSIVE
    executorMode: "NORMAL"
    # This is ignored if enableRawHtmlMarkupFormatter is true
    markupFormatter: plainText
    customJenkinsLabels: []
    # The default configuration uses this secret to configure an admin user
    # If you don't need that user or use a different security realm then you can disable it
    adminSecret: true

    hostNetworking: false
    # When enabling LDAP or another non-Jenkins identity source, the built-in admin account will no longer exist.
    # If you disable the non-Jenkins identity store and instead use the Jenkins internal one,
    # you should revert controller.adminUser to your preferred admin user:
    adminUser: "admin"
    adminPassword: "Radio101"

    # This values should not be changed unless you use your custom image of jenkins or any devired from. If you want to use
    # Cloudbees Jenkins Distribution docker, you should set jenkinsHome: "/var/cloudbees-jenkins-distribution"
    jenkinsHome: "/var/jenkins_home"
    # This values should not be changed unless you use your custom image of jenkins or any devired from. If you want to use
    # Cloudbees Jenkins Distribution docker, you should set jenkinsRef: "/usr/share/cloudbees-jenkins-distribution/ref"
    jenkinsRef: "/usr/share/jenkins/ref"
    # Path to the jenkins war file which is used by jenkins-plugin-cli.
    jenkinsWar: "/usr/share/jenkins/jenkins.war"
    # Overrides the default arguments passed to the war
    # overrideArgs:
    #   - --httpPort=8080
    resources:
      requests:
        cpu: "50m"
        memory: "256Mi"
      limits:
        cpu: "2000m"
        memory: "4096Mi"
    # Overrides the init container default values
    # initContainerResources:
    #   requests:
    #     cpu: "50m"
    #     memory: "256Mi"
    #   limits:
    #     cpu: "2000m"
    #     memory: "4096Mi"
    # Environment variables that get added to the init container (useful for e.g. http_proxy)
    # initContainerEnv:
    #   - name: http_proxy
    #     value: "http://192.168.64.1:3128"
    # containerEnv:
    #   - name: http_proxy
    #     value: "http://192.168.64.1:3128"
    # Set min/max heap here if needed with:
    # javaOpts: "-Xms512m -Xmx512m"
    # jenkinsOpts: ""
    # If you are using the ingress definitions provided by this chart via the `controller.ingress` block the configured hostname will be the ingress hostname starting with `https://` or `http://` depending on the `tls` configuration.
    # The Protocol can be overwritten by specifying `controller.jenkinsUrlProtocol`.
    # jenkinsUrlProtocol: "https"
    # If you are not using the provided ingress you can specify `controller.jenkinsUrl` to change the url definition.
    # jenkinsUrl: ""
    # If you set this prefix and use ingress controller then you might want to set the ingress path below
    # jenkinsUriPrefix: "/jenkins"
    # Enable pod security context (must be `true` if podSecurityContextOverride, runAsUser or fsGroup are set)
    usePodSecurityContext: true
    # Note that `runAsUser`, `fsGroup`, and `securityContextCapabilities` are
    # being deprecated and replaced by `podSecurityContextOverride`.
    # Set runAsUser to 1000 to let Jenkins run as non-root user 'jenkins' which exists in 'jenkins/jenkins' docker image.
    # When setting runAsUser to a different value than 0 also set fsGroup to the same value:
    runAsUser: 1000
    fsGroup: 1000
    # If you have PodSecurityPolicies that require dropping of capabilities as suggested by CIS K8s benchmark, put them here
    securityContextCapabilities: {}
    #  drop:
    #    - NET_RAW
    # Completely overwrites the contents of the `securityContext`, ignoring the
    # values provided for the deprecated fields: `runAsUser`, `fsGroup`, and
    # `securityContextCapabilities`.  In the case of mounting an ext4 filesystem,
    # it might be desirable to use `supplementalGroups` instead of `fsGroup` in
    # the `securityContext` block: https://github.com/kubernetes/kubernetes/issues/67014#issuecomment-589915496
    # podSecurityContextOverride:
    #   runAsUser: 1000
    #   runAsNonRoot: true
    #   supplementalGroups: [1000]
    #   # capabilities: {}
    # Container securityContext
    containerSecurityContext:
      runAsUser: 1000
      runAsGroup: 1000
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
    servicePort: 8080
    targetPort: 8080
    # For minikube, set this to NodePort, elsewhere use LoadBalancer
    # Use ClusterIP if your setup includes ingress controller
    serviceType: ClusterIP
    # Use Local to preserve the client source IP and avoids a second hop for LoadBalancer and Nodeport type services,
    # but risks potentially imbalanced traffic spreading.
    serviceExternalTrafficPolicy:
    # Jenkins controller service annotations
    serviceAnnotations: {}
    # Jenkins controller custom labels
    statefulSetLabels: {}
    #   foo: bar
    #   bar: foo
    # Jenkins controller service labels
    serviceLabels: {}
    #   service.beta.kubernetes.io/aws-load-balancer-backend-protocol: https
    # Put labels on Jenkins controller pod
    podLabels: {}
    # Used to create Ingress record (should used with ServiceType: ClusterIP)
    # nodePort: <to set explicitly, choose port between 30000-32767
    # Enable Kubernetes Startup, Liveness and Readiness Probes
    # if Startup Probe is supported, enable it too
    # ~ 2 minutes to allow Jenkins to restart when upgrading plugins. Set ReadinessTimeout to be shorter than LivenessTimeout.
    healthProbes: true
    probes:
      startupProbe:
        httpGet:
          path: '{{ default "" .Values.controller.jenkinsUriPrefix }}/login'
          port: http
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 12
      livenessProbe:
        failureThreshold: 5
        httpGet:
          path: '{{ default "" .Values.controller.jenkinsUriPrefix }}/login'
          port: http
        periodSeconds: 10
        timeoutSeconds: 5
        # If Startup Probe is not supported on your Kubernetes cluster, you might want to use "initialDelaySeconds" instead.
        # It delays the initial liveness probe while Jenkins is starting
        # initialDelaySeconds: 60
      readinessProbe:
        failureThreshold: 3
        httpGet:
          path: '{{ default "" .Values.controller.jenkinsUriPrefix }}/login'
          port: http
        periodSeconds: 10
        timeoutSeconds: 5
        # If Startup Probe is not supported on your Kubernetes cluster, you might want to use "initialDelaySeconds" instead.
        # It delays the initial readyness probe while Jenkins is starting
        # initialDelaySeconds: 60

    # PodDisruptionBudget config
    podDisruptionBudget:
      enabled: false
      # For Kubernetes v1.5+, use 'policy/v1beta1'
      # For Kubernetes v1.21+, use 'policy/v1'
      apiVersion: "policy/v1beta1"
      annotations: {}
      labels: {}
      # maxUnavailable: "0"

    agentListenerEnabled: true
    agentListenerPort: 50000
    agentListenerHostPort:
    agentListenerNodePort:
    agentListenerExternalTrafficPolicy:
    agentListenerLoadBalancerSourceRanges:
    - 0.0.0.0/0
    disabledAgentProtocols:
      - JNLP-connect
      - JNLP2-connect
    csrf:
      defaultCrumbIssuer:
        enabled: true
        proxyCompatability: true
    # Kubernetes service type for the JNLP agent service
    # agentListenerServiceType is the Kubernetes Service type for the JNLP agent service,
    # either 'LoadBalancer', 'NodePort', or 'ClusterIP'
    # Note if you set this to 'LoadBalancer', you *must* define annotations to secure it. By default
    # this will be an external load balancer and allowing inbound 0.0.0.0/0, a HUGE
    # security risk:  https://github.com/kubernetes/charts/issues/1341
    agentListenerServiceType: "ClusterIP"
    # Optionally assign an IP to the LoadBalancer agentListenerService LoadBalancer
    # GKE users: only regional static IPs will work for Service Load balancer.
    agentListenerLoadBalancerIP:
    agentListenerServiceAnnotations: {}

    # Example of 'LoadBalancer' type of agent listener with annotations securing it
    # agentListenerServiceType: LoadBalancer
    # agentListenerServiceAnnotations:
    #   service.beta.kubernetes.io/aws-load-balancer-internal: "True"
    #   service.beta.kubernetes.io/load-balancer-source-ranges: "172.0.0.0/8, 10.0.0.0/8"

    # LoadBalancerSourcesRange is a list of allowed CIDR values, which are combined with ServicePort to
    # set allowed inbound rules on the security group assigned to the controller load balancer
    loadBalancerSourceRanges:
    - 0.0.0.0/0
    # Optionally assign a known public LB IP
    # loadBalancerIP: 1.2.3.4
    # Optionally configure a JMX port
    # requires additional javaOpts, ie
    # javaOpts: >
    #   -Dcom.sun.management.jmxremote.port=4000
    #   -Dcom.sun.management.jmxremote.authenticate=false
    #   -Dcom.sun.management.jmxremote.ssl=false
    # jmxPort: 4000
    # Optionally configure other ports to expose in the controller container
    extraPorts: []
    # - name: BuildInfoProxy
    #   port: 9000
    #   targetPort: 9010 (Optional: Use to explicitly set targetPort if different from port)

    # List of plugins to be install during Jenkins controller start
    installPlugins:
      - kubernetes:3734.v562b_b_a_627ea_c
      - workflow-aggregator:590.v6a_d052e5a_a_b_5
      - git:4.13.0
      - configuration-as-code:1569.vb_72405b_80249

    # Set to false to download the minimum required version of all dependencies.
    installLatestPlugins: true

    # Set to true to download latest dependencies of any plugin that is requested to have the latest version.
    installLatestSpecifiedPlugins: false

    # List of plugins to install in addition to those listed in controller.installPlugins
    additionalPlugins: []

    # Enable to initialize the Jenkins controller only once on initial installation.
    # Without this, whenever the controller gets restarted (Evicted, etc.) it will fetch plugin updates which has the potential to cause breakage.
    # Note that for this to work, `persistence.enabled` needs to be set to `true`
    initializeOnce: false

    # Enable to always override the installed plugins with the values of 'controller.installPlugins' on upgrade or redeployment.
    # overwritePlugins: true

    # Configures if plugins bundled with `controller.image` should be overwritten with the values of 'controller.installPlugins' on upgrade or redeployment.
    overwritePluginsFromImage: true

    # Configures the restrictions for naming projects. Set this key to null or empty to skip it in the default config.
    projectNamingStrategy: standard

    # Enable HTML parsing using OWASP Markup Formatter Plugin (antisamy-markup-formatter), useful with ghprb plugin.
    # The plugin is not installed by default, please update controller.installPlugins.
    enableRawHtmlMarkupFormatter: false
    # Used to approve a list of groovy functions in pipelines used the script-security plugin. Can be viewed under /scriptApproval
    scriptApproval: []
    #  - "method groovy.json.JsonSlurperClassic parseText java.lang.String"
    #  - "new groovy.json.JsonSlurperClassic"
    # List of groovy init scripts to be executed during Jenkins controller start
    initScripts: []
    #  - |
    #    print 'adding global pipeline libraries, register properties, bootstrap jobs...'

    # 'name' is a name of an existing secret in same namespace as jenkins,
    # 'keyName' is the name of one of the keys inside current secret.
    # the 'name' and 'keyName' are concatenated with a '-' in between, so for example:
    # an existing secret "secret-credentials" and a key inside it named "github-password" should be used in Jcasc as ${secret-credentials-github-password}
    # 'name' and 'keyName' must be lowercase RFC 1123 label must consist of lower case alphanumeric characters or '-',
    # and must start and end with an alphanumeric character (e.g. 'my-name',  or '123-abc')
    # existingSecret existing secret "secret-credentials" and a key inside it named "github-username" should be used in Jcasc as ${github-username}
    # When using existingSecret no need to specify the keyName under additionalExistingSecrets.
    existingSecret:

    additionalExistingSecrets: []
    #  - name: secret-name-1
    #    keyName: username
    #  - name: secret-name-1
    #    keyName: password

    additionalSecrets: []
    #  - name: nameOfSecret
    #    value: secretText

    # Generate SecretClaim resources in order to create Kubernetes secrets from HashiCorp Vault using kube-vault-controller.
    # 'name' is name of the secret that will be created in Kubernetes. The Jenkins fullname is prepended to this value.
    # 'path' is the fully qualified path to the secret in Vault
    # 'type' is an optional Kubernetes secret type. Defaults to 'Opaque'
    # 'renew' is an optional secret renewal time in seconds
    secretClaims: []
    # - name: secretName        # required
    #   path: testPath          # required
    #   type: kubernetes.io/tls # optional
    #   renew: 60               # optional

    # Name of default cloud configuration.
    cloudName: "kubernetes"

    # Below is the implementation of Jenkins Configuration as Code.  Add a key under configScripts for each configuration area,
    # where each corresponds to a plugin or section of the UI.  Each key (prior to | character) is just a label, and can be any value.
    # Keys are only used to give the section a meaningful name.  The only restriction is they may only contain RFC 1123 \ DNS label
    # characters: lowercase letters, numbers, and hyphens.  The keys become the name of a configuration yaml file on the controller in
    # /var/jenkins_home/casc_configs (by default) and will be processed by the Configuration as Code Plugin.  The lines after each |
    # become the content of the configuration yaml file.  The first line after this is a JCasC root element, eg jenkins, credentials,
    # etc.  Best reference is https://<jenkins_url>/configuration-as-code/reference.  The example below creates a welcome message:
    JCasC:
      defaultConfig: true
      configUrls: []
      # - https://acme.org/jenkins.yaml
      # Remote URL:s for configuration files.
      configScripts: {}
      #  welcome-message: |
      #    jenkins:
      #      systemMessage: Welcome to our CI\CD server.  This Jenkins is configured and managed 'as code'.
      # Allows adding to the top-level security JCasC section. For legacy,  default the chart includes apiToken configurations
      security:
        apiToken:
          creationOfLegacyTokenEnabled: false
          tokenGenerationOnCreationEnabled: false
          usageStatisticsEnabled: true
      # Ignored if securityRealm is defined in controller.JCasC.configScripts
      securityRealm: |-
        local:
          allowsSignup: false
          enableCaptcha: false
          users:
          - id: "${chart-admin-username}"
            name: "Jenkins Admin"
            password: "${chart-admin-password}"
      # Ignored if authorizationStrategy is defined in controller.JCasC.configScripts
      authorizationStrategy: |-
        loggedInUsersCanDoAnything:
          allowAnonymousRead: false
    # Optionally specify additional init-containers
    customInitContainers: []
    # - name: custom-init
    #   image: "alpine:3.7"
    #   imagePullPolicy: Always
    #   command: [ "uname", "-a" ]

    sidecars:
      configAutoReload:
        # If enabled: true, Jenkins Configuration as Code will be reloaded on-the-fly without a reboot.  If false or not-specified,
        # jcasc changes will cause a reboot and will only be applied at the subsequent start-up.  Auto-reload uses the
        # http://<jenkins_url>/reload-configuration-as-code endpoint to reapply config when changes to the configScripts are detected.
        enabled: true
        image: kiwigrid/k8s-sidecar:1.15.0
        imagePullPolicy: IfNotPresent
        resources: {}
          #   limits:
          #     cpu: 100m
          #     memory: 100Mi
          #   requests:
          #     cpu: 50m
          #     memory: 50Mi
        # How many connection-related errors to retry on
        reqRetryConnect: 10
        # env:
        #   - name: REQ_TIMEOUT
        #     value: "30"
        # SSH port value can be set to any unused TCP port.  The default, 1044, is a non-standard SSH port that has been chosen at random.
        # Is only used to reload jcasc config from the sidecar container running in the Jenkins controller pod.
        # This TCP port will not be open in the pod (unless you specifically configure this), so Jenkins will not be
        # accessible via SSH from outside of the pod.  Note if you use non-root pod privileges (runAsUser & fsGroup),
        # this must be > 1024:
        sshTcpPort: 1044
        # folder in the pod that should hold the collected dashboards:
        folder: "/var/jenkins_home/casc_configs"
        # If specified, the sidecar will search for JCasC config-maps inside this namespace.
        # Otherwise the namespace in which the sidecar is running will be used.
        # It's also possible to specify ALL to search in all namespaces:
        # searchNamespace:
        containerSecurityContext:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false

      # Allows you to inject additional/other sidecars
      other: []
      ## The example below runs the client for https://smee.io as sidecar container next to Jenkins,
      ## that allows to trigger build behind a secure firewall.
      ## https://jenkins.io/blog/2019/01/07/webhook-firewalls/#triggering-builds-with-webhooks-behind-a-secure-firewall
      ##
      ## Note: To use it you should go to https://smee.io/new and update the url to the generete one.
      # - name: smee
      #   image: docker.io/twalter/smee-client:1.0.2
      #   args: ["--port", "{{ .Values.controller.servicePort }}", "--path", "/github-webhook/", "--url", "https://smee.io/new"]
      #   resources:
      #     limits:
      #       cpu: 50m
      #       memory: 128Mi
      #     requests:
      #       cpu: 10m
      #       memory: 32Mi
    # Name of the Kubernetes scheduler to use
    schedulerName: ""
    # Node labels and tolerations for pod assignment
    # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
    # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
    nodeSelector: {}

    terminationGracePeriodSeconds:

    terminationMessagePath:
    terminationMessagePolicy:

    tolerations: []

    affinity: {}
    # Leverage a priorityClass to ensure your pods survive resource shortages
    # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
    priorityClassName:

    podAnnotations: {}
    # Add StatefulSet annotations
    statefulSetAnnotations: {}

    # StatefulSet updateStrategy
    # ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
    updateStrategy: {}

    ingress:
      enabled: false
      # Override for the default paths that map requests to the backend
      paths: []
      # - backend:
      #     serviceName: ssl-redirect
      #     servicePort: use-annotation
      # - backend:
      #     serviceName: >-
      #       {{ template "jenkins.fullname" . }}
      #     # Don't use string here, use only integer value!
      #     servicePort: 8080
      # For Kubernetes v1.14+, use 'networking.k8s.io/v1beta1'
      # For Kubernetes v1.19+, use 'networking.k8s.io/v1'
      apiVersion: "extensions/v1beta1"
      labels: {}
      annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
      # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
      # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress
      # ingressClassName: nginx
      # Set this path to jenkinsUriPrefix above or use annotations to rewrite path
      # path: "/jenkins"
      # configures the hostname e.g. jenkins.example.com
      hostName:
      tls:
      # - secretName: jenkins.cluster.local
      #   hosts:
      #     - jenkins.cluster.local

    # often you want to have your controller all locked down and private
    # but you still want to get webhooks from your SCM
    # A secondary ingress will let you expose different urls
    # with a differnt configuration
    secondaryingress:
      enabled: false
      # paths you want forwarded to the backend
      # ex /github-webhook
      paths: []
      # For Kubernetes v1.14+, use 'networking.k8s.io/v1beta1'
      # For Kubernetes v1.19+, use 'networking.k8s.io/v1'
      apiVersion: "extensions/v1beta1"
      labels: {}
      annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
      # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
      # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress
      # ingressClassName: nginx
      # configures the hostname e.g. jenkins-external.example.com
      hostName:
      tls:
      # - secretName: jenkins-external.example.com
      #   hosts:
      #     - jenkins-external.example.com

    # If you're running on GKE and need to configure a backendconfig
    # to finish ingress setup, use the following values.
    # Docs: https://cloud.google.com/kubernetes-engine/docs/concepts/backendconfig
    backendconfig:
      enabled: false
      apiVersion: "extensions/v1beta1"
      name:
      labels: {}
      annotations: {}
      spec: {}

    # Openshift route
    route:
      enabled: false
      labels: {}
      annotations: {}
      # path: "/jenkins"

    # controller.hostAliases allows for adding entries to Pod /etc/hosts:
    # https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
    hostAliases: []
    # - ip: 192.168.50.50
    #   hostnames:
    #     - something.local
    # - ip: 10.0.50.50
    #   hostnames:
    #     - other.local

    # Expose Prometheus metrics
    prometheus:
      # If enabled, add the prometheus plugin to the list of plugins to install
      # https://plugins.jenkins.io/prometheus
      enabled: false
      # Additional labels to add to the ServiceMonitor object
      serviceMonitorAdditionalLabels: {}
      # Set a custom namespace where to deploy ServiceMonitor resource
      # serviceMonitorNamespace: monitoring
      scrapeInterval: 60s
      # This is the default endpoint used by the prometheus plugin
      scrapeEndpoint: /prometheus
      # Additional labels to add to the PrometheusRule object
      alertingRulesAdditionalLabels: {}
      # An array of prometheus alerting rules
      # See here: https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/
      # The `groups` root object is added by default, simply add the rule entries
      alertingrules: []
      # Set a custom namespace where to deploy PrometheusRule resource
      prometheusRuleNamespace: ""

      # RelabelConfigs to apply to samples before scraping. Prometheus Operator automatically adds
      # relabelings for a few standard Kubernetes fields. The original scrape job’s name
      # is available via the __tmp_prometheus_job_name label.
      # More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
      relabelings: []
      # MetricRelabelConfigs to apply to samples before ingestion.
      metricRelabelings: []

    googlePodMonitor:
      # If enabled, It creates Google Managed Prometheus scraping config
      enabled: false
      # Set a custom namespace where to deploy PodMonitoring resource
      # serviceMonitorNamespace: ""
      scrapeInterval: 60s
      # This is the default endpoint used by the prometheus plugin
      scrapeEndpoint: /prometheus

    # Can be used to disable rendering controller test resources when using helm template
    testEnabled: true

    httpsKeyStore:
      jenkinsHttpsJksSecretName: ''
      enable: false
      httpPort: 8081
      path: "/var/jenkins_keystore"
      fileName: "keystore.jks"
      password: "password"
      # Convert keystore.jks files content to base64 ( cat keystore.jks | base64 ) and put the output here
      jenkinsKeyStoreBase64Encoded: |
          /u3+7QAAAAIAAAABAAAAAQANamVua2luc2NpLmNvbQAAAW2r/b1ZAAAFATCCBP0wDgYKKwYBBAEq
          AhEBAQUABIIE6QbCqasvoHS0pSwYqSvdydMCB9t+VNfwhFIiiuAelJfO5sSe2SebJbtwHgLcRz1Z
          gMtWgOSFdl3bWSzA7vrW2LED52h+jXLYSWvZzuDuh8hYO85m10ikF6QR+dTi4jra0whIFDvq3pxe
          TnESxEsN+DvbZM3jA3qsjQJSeISNpDjO099dqQvHpnCn18lyk7J4TWJ8sOQQb1EM2zDAfAOSqA/x
          QuPEFl74DlY+5DIk6EBvpmWhaMSvXzWZACGA0sYqa157dq7O0AqmuLG/EI5EkHETO4CrtBW+yLcy
          2dUCXOMA+j+NjM1BjrQkYE5vtSfNO6lFZcISyKo5pTFlcA7ut0Fx2nZ8GhHTn32CpeWwNcZBn1gR
          pZVt6DxVVkhTAkMLhR4rL2wGIi/1WRs23ZOLGKtyDNvDHnQyDiQEoJGy9nAthA8aNHa3cfdF10vB
          Drb19vtpFHmpvKEEhpk2EBRF4fTi644Fuhu2Ied6118AlaPvEea+n6G4vBz+8RWuVCmZjLU+7h8l
          Hy3/WdUPoIL5eW7Kz+hS+sRTFzfu9C48dMkQH3a6f3wSY+mufizNF9U298r98TnYy+PfDJK0bstG
          Ph6yPWx8DGXKQBwrhWJWXI6JwZDeC5Ny+l8p1SypTmAjpIaSW3ge+KgcL6Wtt1R5hUV1ajVwVSUi
          HF/FachKqPqyLJFZTGjNrxnmNYpt8P1d5JTvJfmfr55Su/P9n7kcyWp7zMcb2Q5nlXt4tWogOHLI
          OzEWKCacbFfVHE+PpdrcvCVZMDzFogIq5EqGTOZe2poPpBVE+1y9mf5+TXBegy5HToLWvmfmJNTO
          NCDuBjgLs2tdw2yMPm4YEr57PnMX5gGTC3f2ZihXCIJDCRCdQ9sVBOjIQbOCzxFXkVITo0BAZhCi
          Yz61wt3Ud8e//zhXWCkCsSV+IZCxxPzhEFd+RFVjW0Nm9hsb2FgAhkXCjsGROgoleYgaZJWvQaAg
          UyBzMmKDPKTllBHyE3Gy1ehBNGPgEBChf17/9M+j8pcm1OmlM434ctWQ4qW7RU56//yq1soFY0Te
          fu2ei03a6m68fYuW6s7XEEK58QisJWRAvEbpwu/eyqfs7PsQ+zSgJHyk2rO95IxdMtEESb2GRuoi
          Bs+AHNdYFTAi+GBWw9dvEgqQ0Mpv0//6bBE/Fb4d7b7f56uUNnnE7mFnjGmGQN+MvC62pfwfvJTT
          EkT1iZ9kjM9FprTFWXT4UmO3XTvesGeE50sV9YPm71X4DCQwc4KE8vyuwj0s6oMNAUACW2ClU9QQ
          y0tRpaF1tzs4N42Q5zl0TzWxbCCjAtC3u6xf+c8MCGrr7DzNhm42LOQiHTa4MwX4x96q7235oiAU
          iQqSI/hyF5yLpWw4etyUvsx2/0/0wkuTU1FozbLoCWJEWcPS7QadMrRRISxHf0YobIeQyz34regl
          t1qSQ3dCU9D6AHLgX6kqllx4X0fnFq7LtfN7fA2itW26v+kAT2QFZ3qZhINGfofCja/pITC1uNAZ
          gsJaTMcQ600krj/ynoxnjT+n1gmeqThac6/Mi3YlVeRtaxI2InL82ZuD+w/dfY9OpPssQjy3xiQa
          jPuaMWXRxz/sS9syOoGVH7XBwKrWpQcpchozWJt40QV5DslJkclcr8aC2AGlzuJMTdEgz1eqV0+H
          bAXG9HRHN/0eJTn1/QAAAAEABVguNTA5AAADjzCCA4swggJzAhRGqVxH4HTLYPGO4rzHcCPeGDKn
          xTANBgkqhkiG9w0BAQsFADCBgTELMAkGA1UEBhMCY2ExEDAOBgNVBAgMB29udGFyaW8xEDAOBgNV
          BAcMB3Rvcm9udG8xFDASBgNVBAoMC2plbmtpbnN0ZXN0MRkwFwYDVQQDDBBqZW5raW5zdGVzdC5p
          bmZvMR0wGwYJKoZIhvcNAQkBFg50ZXN0QHRlc3QuaW5mbzAeFw0xOTEwMDgxNTI5NTVaFw0xOTEx
          MDcxNTI5NTVaMIGBMQswCQYDVQQGEwJjYTEQMA4GA1UECAwHb250YXJpbzEQMA4GA1UEBwwHdG9y
          b250bzEUMBIGA1UECgwLamVua2luc3Rlc3QxGTAXBgNVBAMMEGplbmtpbnN0ZXN0LmluZm8xHTAb
          BgkqhkiG9w0BCQEWDnRlc3RAdGVzdC5pbmZvMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
          AQEA02q352JTHGvROMBhSHvSv+vnoOTDKSTz2aLQn0tYrIRqRo+8bfmMjXuhkwZPSnCpvUGNAJ+w
          Jrt/dqMoYUjCBkjylD/qHmnXN5EwS1cMg1Djh65gi5JJLFJ7eNcoSsr/0AJ+TweIal1jJSP3t3PF
          9Uv21gm6xdm7HnNK66WpUUXLDTKaIs/jtagVY1bLOo9oEVeLN4nT2CYWztpMvdCyEDUzgEdDbmrP
          F5nKUPK5hrFqo1Dc5rUI4ZshL3Lpv398aMxv6n2adQvuL++URMEbXXBhxOrT6rCtYzbcR5fkwS9i
          d3Br45CoWOQro02JAepoU0MQKY5+xQ4Bq9Q7tB9BAwIDAQABMA0GCSqGSIb3DQEBCwUAA4IBAQAe
          4xc+mSvKkrKBHg9/zpkWgZUiOp4ENJCi8H4tea/PCM439v6y/kfjT/okOokFvX8N5aa1OSz2Vsrl
          m8kjIc6hiA7bKzT6lb0EyjUShFFZ5jmGVP4S7/hviDvgB5yEQxOPpumkdRP513YnEGj/o9Pazi5h
          /MwpRxxazoda9r45kqQpyG+XoM4pB+Fd3JzMc4FUGxfVPxJU4jLawnJJiZ3vqiSyaB0YyUL+Er1Q
          6NnqtR4gEBF0ZVlQmkycFvD4EC2boP943dLqNUvop+4R3SM1QMM6P5u8iTXtHd/VN4MwMyy1wtog
          hYAzODo1Jt59pcqqKJEas0C/lFJEB3frw4ImNx5fNlJYOpx+ijfQs9m39CevDq0=

  agent:
    enabled: true
    defaultsProviderTemplate: ""
    # URL for connecting to the Jenkins contoller
    jenkinsUrl:
    # connect to the specified host and port, instead of connecting directly to the Jenkins controller
    jenkinsTunnel:
    kubernetesConnectTimeout: 5
    kubernetesReadTimeout: 15
    maxRequestsPerHostStr: "32"
    namespace:
    image: "jenkins/inbound-agent"
    tag: "4.11.2-4"
    workingDir: "/home/jenkins/agent"
    nodeUsageMode: "NORMAL"
    customJenkinsLabels: []
    # name of the secret to be used for image pulling
    imagePullSecretName:
    componentName: "jenkins-agent"
    websocket: false
    privileged: false
    runAsUser:
    runAsGroup:
    hostNetworking: false
    resources:
      requests:
        cpu: "512m"
        memory: "512Mi"
      limits:
        cpu: "512m"
        memory: "512Mi"
    # You may want to change this to true while testing a new image
    alwaysPullImage: false
    # Controls how agent pods are retained after the Jenkins build completes
    # Possible values: Always, Never, OnFailure
    podRetention: "Never"
    # Disable if you do not want the Yaml the agent pod template to show up
    # in the job Console Output. This can be helpful for either security reasons
    # or simply to clean up the output to make it easier to read.
    showRawYaml: true
    # You can define the volumes that you want to mount for this container
    # Allowed types are: ConfigMap, EmptyDir, HostPath, Nfs, PVC, Secret
    # Configure the attributes as they appear in the corresponding Java class for that type
    # https://github.com/jenkinsci/kubernetes-plugin/tree/master/src/main/java/org/csanchez/jenkins/plugins/kubernetes/volumes
    volumes: []
    # - type: ConfigMap
    #   configMapName: myconfigmap
    #   mountPath: /var/myapp/myconfigmap
    # - type: EmptyDir
    #   mountPath: /var/myapp/myemptydir
    #   memory: false
    # - type: HostPath
    #   hostPath: /var/lib/containers
    #   mountPath: /var/myapp/myhostpath
    # - type: Nfs
    #   mountPath: /var/myapp/mynfs
    #   readOnly: false
    #   serverAddress: "192.0.2.0"
    #   serverPath: /var/lib/containers
    # - type: PVC
    #   claimName: mypvc
    #   mountPath: /var/myapp/mypvc
    #   readOnly: false
    # - type: Secret
    #   defaultMode: "600"
    #   mountPath: /var/myapp/mysecret
    #   secretName: mysecret
    # Pod-wide environment, these vars are visible to any container in the agent pod

    # You can define the workspaceVolume that you want to mount for this container
    # Allowed types are: DynamicPVC, EmptyDir, HostPath, Nfs, PVC
    # Configure the attributes as they appear in the corresponding Java class for that type
    # https://github.com/jenkinsci/kubernetes-plugin/tree/master/src/main/java/org/csanchez/jenkins/plugins/kubernetes/volumes/workspace
    workspaceVolume: {}
    ## DynamicPVC example
    # type: DynamicPVC
    # configMapName: myconfigmap
    ## EmptyDir example
    # type: EmptyDir
    # memory: false
    ## HostPath example
    # type: HostPath
    # hostPath: /var/lib/containers
    ## NFS example
    # type: Nfs
    # readOnly: false
    # serverAddress: "192.0.2.0"
    # serverPath: /var/lib/containers
    ## PVC example
    # type: PVC
    # claimName: mypvc
    # readOnly: false
    #
    # Pod-wide environment, these vars are visible to any container in the agent pod
    envVars: []
    # - name: PATH
    #   value: /usr/local/bin
    # Mount a secret as environment variable
    secretEnvVars: []
    # - key: PATH
    #   optional: false # default: false
    #   secretKey: MY-K8S-PATH
    #   secretName: my-k8s-secret
    nodeSelector: {}
    # Key Value selectors. Ex:
    # jenkins-agent: v1

    # Executed command when side container gets started
    command:
    args: "${computer.jnlpmac} ${computer.name}"
    # Side container name
    sideContainerName: "jnlp"
    # Doesn't allocate pseudo TTY by default
    TTYEnabled: false
    # Max number of spawned agent
    containerCap: 10
    # Pod name
    podName: "default"
    # Allows the Pod to remain active for reuse until the configured number of
    # minutes has passed since the last step was executed on it.
    idleMinutes: 0
    # Raw yaml template for the Pod. For example this allows usage of toleration for agent pods.
    # https://github.com/jenkinsci/kubernetes-plugin#using-yaml-to-define-pod-templates
    # https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    yamlTemplate: ""
    # yamlTemplate: |-
    #   apiVersion: v1
    #   kind: Pod
    #   spec:
    #     tolerations:
    #     - key: "key"
    #       operator: "Equal"
    #       value: "value"
    # Defines how the raw yaml field gets merged with yaml definitions from inherited pod templates: merge or override
    yamlMergeStrategy: "override"
    # Timeout in seconds for an agent to be online
    connectTimeout: 100
    # Annotations to apply to the pod.
    annotations: {}

    # Add additional containers to the agents.
    # Containers specified here are added to all agents. Set key empty to remove container from additional agents.
    additionalContainers: []
    #  - sideContainerName: dind
    #    image: docker
    #    tag: dind
    #    command: dockerd-entrypoint.sh
    #    args: ""
    #    privileged: true
    #    resources:
    #      requests:
    #        cpu: 500m
    #        memory: 1Gi
    #      limits:
    #        cpu: 1
    #        memory: 2Gi

    # Disable the default Jenkins Agent configuration.
    # Useful when configuring agents only with the podTemplates value, since the default podTemplate populated by values mentioned above will be excluded in the rendered template.
    disableDefaultAgent: false

    # Below is the implementation of custom pod templates for the default configured kubernetes cloud.
    # Add a key under podTemplates for each pod template. Each key (prior to | character) is just a label, and can be any value.
    # Keys are only used to give the pod template a meaningful name.  The only restriction is they may only contain RFC 1123 \ DNS label
    # characters: lowercase letters, numbers, and hyphens. Each pod template can contain multiple containers.
    # For this pod templates configuration to be loaded the following values must be set:
    # controller.JCasC.defaultConfig: true
    # Best reference is https://<jenkins_url>/configuration-as-code/reference#Cloud-kubernetes. The example below creates a python pod template.
    podTemplates: {}
    #  python: |
    #    - name: python
    #      label: jenkins-python
    #      serviceAccount: jenkins
    #      containers:
    #        - name: python
    #          image: python:3
    #          command: "/bin/sh -c"
    #          args: "cat"
    #          ttyEnabled: true
    #          privileged: true
    #          resourceRequestCpu: "400m"
    #          resourceRequestMemory: "512Mi"
    #          resourceLimitCpu: "1"
    #          resourceLimitMemory: "1024Mi"

  # Here you can add additional agents
  # They inherit all values from `agent` so you only need to specify values which differ
  additionalAgents: {}
  #  maven:
  #    podName: maven
  #    customJenkinsLabels: maven
  #    # An example of overriding the jnlp container
  #    # sideContainerName: jnlp
  #    image: jenkins/jnlp-agent-maven
  #    tag: latest
  #  python:
  #    podName: python
  #    customJenkinsLabels: python
  #    sideContainerName: python
  #    image: python
  #    tag: "3"
  #    command: "/bin/sh -c"
  #    args: "cat"
  #    TTYEnabled: true

  persistence:
    enabled: true
    ## A manually managed Persistent Volume and Claim
    ## Requires persistence.enabled: true
    ## If defined, PVC must be created manually before volume will be bound
    existingClaim:
    ## jenkins data Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    storageClass:
    annotations: {}
    labels: {}
    accessMode: "ReadWriteOnce"
    size: "8Gi"
    volumes:
    #  - name: nothing
    #    emptyDir: {}
    mounts:
    #  - mountPath: /var/nothing
    #    name: nothing
    #    readOnly: true

  networkPolicy:
    # Enable creation of NetworkPolicy resources.
    enabled: false
    # For Kubernetes v1.4, v1.5 and v1.6, use 'extensions/v1beta1'
    # For Kubernetes v1.7, use 'networking.k8s.io/v1'
    apiVersion: networking.k8s.io/v1
    # You can allow agents to connect from both within the cluster (from within specific/all namespaces) AND/OR from a given external IP range
    internalAgents:
      allowed: true
      podLabels: {}
      namespaceLabels: {}
        # project: myproject
    externalAgents: {}
    #   ipCIDR: 172.17.0.0/16
    #   except:
    #     - 172.17.1.0/24

  ## Install Default RBAC roles and bindings
  rbac:
    create: true
    readSecrets: false

  serviceAccount:
    create: true
    # The name of the service account is autogenerated by default
    name:
    annotations: {}
    imagePullSecretName:


  serviceAccountAgent:
    # Specifies whether a ServiceAccount should be created
    create: false
    # The name of the ServiceAccount to use.
    # If not set and create is true, a name is generated using the fullname template
    name:
    annotations: {}
    imagePullSecretName:

  ## Backup cronjob configuration
  ## Ref: https://github.com/maorfr/kube-tasks
  backup:
    # Backup must use RBAC
    # So by enabling backup you are enabling RBAC specific for backup
    enabled: false
    # Used for label app.kubernetes.io/component
    componentName: "backup"
    # Schedule to run jobs. Must be in cron time format
    # Ref: https://crontab.guru/
    schedule: "0 2 * * *"
    labels: {}
    serviceAccount:
      create: true
      name:
      annotations: {}
      # Example for authorization to AWS S3 using kube2iam or IRSA
      # Can also be done using environment variables
      # iam.amazonaws.com/role: "jenkins"
      # "eks.amazonaws.com/role-arn": "arn:aws:iam::123456789012:role/jenkins-backup"
    # Set this to terminate the job that is running/failing continously and set the job status to "Failed"
    activeDeadlineSeconds: ""
    image:
      repository: "maorfr/kube-tasks"
      tag: "0.2.0"
    imagePullSecretName:
    # Additional arguments for kube-tasks
    # Ref: https://github.com/maorfr/kube-tasks#simple-backup
    extraArgs: []
    # Add existingSecret for AWS credentials
    existingSecret: {}
    ## Example for using an existing secret
    # jenkinsaws:
    ## Use this key for AWS access key ID
      # awsaccesskey: jenkins_aws_access_key
    ## Use this key for AWS secret access key
      # awssecretkey: jenkins_aws_secret_key
    # Add additional environment variables
    # jenkinsgcp:
    ## Use this key for GCP credentials
      # gcpcredentials: credentials.json
    env: []
    # Example environment variable required for AWS credentials chain
    # - name: "AWS_REGION"
    #   value: "us-east-1"
    resources:
      requests:
        memory: 1Gi
        cpu: 1
      limits:
        memory: 1Gi
        cpu: 1
    # Destination to store the backup artifacts
    # Supported cloud storage services: AWS S3, Minio S3, Azure Blob Storage, Google Cloud Storage
    # Additional support can added. Visit this repository for details
    # Ref: https://github.com/maorfr/skbn
    destination: "s3://jenkins-data/backup"
    # By enabling only the jenkins_home/jobs folder gets backed up, not the whole jenkins instance
    onlyJobs: false
    # Enable backup pod security context (must be `true` if runAsUser or fsGroup are set)
    usePodSecurityContext: true
    # When setting runAsUser to a different value than 0 also set fsGroup to the same value:
    runAsUser: 1000
    fsGroup: 1000
    securityContextCapabilities: {}
    #  drop:
    #    - NET_RAW
  cronJob:
    apiVersion: batch/v1

  checkDeprecation: true

  awsSecurityGroupPolicies:
    enabled: false
    policies:
      - name: ""
        securityGroupIds: []
        podSelector: {}

postgresql:
  ## @section Global parameters
  ## Please, note that this will override the parameters, including dependencies, configured to use the global value
  ##
  global:
    ## @param global.imageRegistry Global Docker image registry
    ##
    imageRegistry: ""
    ## @param global.imagePullSecrets Global Docker registry secret names as an array
    ## e.g.
    ## imagePullSecrets:
    ##   - myRegistryKeySecretName
    ##
    imagePullSecrets: []
    ## @param global.storageClass Global StorageClass for Persistent Volume(s)
    ##
    storageClass: ""
    postgresql:
      ## @param global.postgresql.auth.postgresPassword Password for the "postgres" admin user (overrides `auth.postgresPassword`)
      ## @param global.postgresql.auth.username Name for a custom user to create (overrides `auth.username`)
      ## @param global.postgresql.auth.password Password for the custom user to create (overrides `auth.password`)
      ## @param global.postgresql.auth.database Name for a custom database to create (overrides `auth.database`)
      ## @param global.postgresql.auth.existingSecret Name of existing secret to use for PostgreSQL credentials (overrides `auth.existingSecret`).
      ## @param global.postgresql.auth.secretKeys.adminPasswordKey Name of key in existing secret to use for PostgreSQL credentials (overrides `auth.secretKeys.adminPasswordKey`). Only used when `global.postgresql.auth.existingSecret` is set.
      ## @param global.postgresql.auth.secretKeys.userPasswordKey Name of key in existing secret to use for PostgreSQL credentials (overrides `auth.secretKeys.userPasswordKey`). Only used when `global.postgresql.auth.existingSecret` is set.
      ## @param global.postgresql.auth.secretKeys.replicationPasswordKey Name of key in existing secret to use for PostgreSQL credentials (overrides `auth.secretKeys.replicationPasswordKey`). Only used when `global.postgresql.auth.existingSecret` is set.
      ##
      auth:
        postgresPassword: "Radio101"
        username: "admin"
        password: "Radio101"
        database: ""
        existingSecret: ""
        secretKeys:
          adminPasswordKey: ""
          userPasswordKey: ""
          replicationPasswordKey: ""
      ## @param global.postgresql.service.ports.postgresql PostgreSQL service port (overrides `service.ports.postgresql`)
      ##
      service:
        ports:
          postgresql: ""

  ## @section Common parameters
  ##

  ## @param kubeVersion Override Kubernetes version
  ##
  kubeVersion: ""
  ## @param nameOverride String to partially override common.names.fullname template (will maintain the release name)
  ##
  nameOverride: ""
  ## @param fullnameOverride String to fully override common.names.fullname template
  ##
  fullnameOverride: ""
  ## @param clusterDomain Kubernetes Cluster Domain
  ##
  clusterDomain: cluster.local
  ## @param extraDeploy Array of extra objects to deploy with the release (evaluated as a template)
  ##
  extraDeploy: []
  ## @param commonLabels Add labels to all the deployed resources
  ##
  commonLabels: {}
  ## @param commonAnnotations Add annotations to all the deployed resources
  ##
  commonAnnotations: {}
  ## Enable diagnostic mode in the statefulset
  ##
  diagnosticMode:
    ## @param diagnosticMode.enabled Enable diagnostic mode (all probes will be disabled and the command will be overridden)
    ##
    enabled: false
    ## @param diagnosticMode.command Command to override all containers in the statefulset
    ##
    command:
      - sleep
    ## @param diagnosticMode.args Args to override all containers in the statefulset
    ##
    args:
      - infinity

  ## @section PostgreSQL common parameters
  ##

  ## Bitnami PostgreSQL image version
  ## ref: https://hub.docker.com/r/bitnami/postgresql/tags/
  ## @param image.registry PostgreSQL image registry
  ## @param image.repository PostgreSQL image repository
  ## @param image.tag PostgreSQL image tag (immutable tags are recommended)
  ## @param image.digest PostgreSQL image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
  ## @param image.pullPolicy PostgreSQL image pull policy
  ## @param image.pullSecrets Specify image pull secrets
  ## @param image.debug Specify if debug values should be set
  ##
  image:
    registry: docker.io
    repository: bitnami/postgresql
    tag: 15.1.0-debian-11-r28
    digest: ""
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/user-guide/images/#pre-pulling-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## Example:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
    ## Set to true if you would like to see extra information on logs
    ##
    debug: false
  ## Authentication parameters
  ## ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#setting-the-root-password-on-first-run
  ## ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#creating-a-database-on-first-run
  ## ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#creating-a-database-user-on-first-run
  ##
  auth:
    ## @param auth.enablePostgresUser Assign a password to the "postgres" admin user. Otherwise, remote access will be blocked for this user
    ##
    enablePostgresUser: true
    ## @param auth.postgresPassword Password for the "postgres" admin user. Ignored if `auth.existingSecret` with key `postgres-password` is provided
    ##
    postgresPassword: ""
    ## @param auth.username Name for a custom user to create
    ##
    username: ""
    ## @param auth.password Password for the custom user to create. Ignored if `auth.existingSecret` with key `password` is provided
    ##
    password: ""
    ## @param auth.database Name for a custom database to create
    ##
    database: ""
    ## @param auth.replicationUsername Name of the replication user
    ##
    replicationUsername: repl_user
    ## @param auth.replicationPassword Password for the replication user. Ignored if `auth.existingSecret` with key `replication-password` is provided
    ##
    replicationPassword: ""
    ## @param auth.existingSecret Name of existing secret to use for PostgreSQL credentials. `auth.postgresPassword`, `auth.password`, and `auth.replicationPassword` will be ignored and picked up from this secret. The secret might also contains the key `ldap-password` if LDAP is enabled. `ldap.bind_password` will be ignored and picked from this secret in this case.
    ##
    existingSecret: ""
    ## @param auth.secretKeys.adminPasswordKey Name of key in existing secret to use for PostgreSQL credentials. Only used when `auth.existingSecret` is set.
    ## @param auth.secretKeys.userPasswordKey Name of key in existing secret to use for PostgreSQL credentials. Only used when `auth.existingSecret` is set.
    ## @param auth.secretKeys.replicationPasswordKey Name of key in existing secret to use for PostgreSQL credentials. Only used when `auth.existingSecret` is set.
    ##
    secretKeys:
      adminPasswordKey: postgres-password
      userPasswordKey: password
      replicationPasswordKey: replication-password
    ## @param auth.usePasswordFiles Mount credentials as a files instead of using an environment variable
    ##
    usePasswordFiles: false
  ## @param architecture PostgreSQL architecture (`standalone` or `replication`)
  ##
  architecture: standalone
  ## Replication configuration
  ## Ignored if `architecture` is `standalone`
  ##
  replication:
    ## @param replication.synchronousCommit Set synchronous commit mode. Allowed values: `on`, `remote_apply`, `remote_write`, `local` and `off`
    ## @param replication.numSynchronousReplicas Number of replicas that will have synchronous replication. Note: Cannot be greater than `readReplicas.replicaCount`.
    ## ref: https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT
    ##
    synchronousCommit: "off"
    numSynchronousReplicas: 0
    ## @param replication.applicationName Cluster application name. Useful for advanced replication settings
    ##
    applicationName: my_application
  ## @param containerPorts.postgresql PostgreSQL container port
  ##
  containerPorts:
    postgresql: 5432
  ## Audit settings
  ## https://github.com/bitnami/containers/tree/main/bitnami/postgresql#auditing
  ## @param audit.logHostname Log client hostnames
  ## @param audit.logConnections Add client log-in operations to the log file
  ## @param audit.logDisconnections Add client log-outs operations to the log file
  ## @param audit.pgAuditLog Add operations to log using the pgAudit extension
  ## @param audit.pgAuditLogCatalog Log catalog using pgAudit
  ## @param audit.clientMinMessages Message log level to share with the user
  ## @param audit.logLinePrefix Template for log line prefix (default if not set)
  ## @param audit.logTimezone Timezone for the log timestamps
  ##
  audit:
    logHostname: false
    logConnections: false
    logDisconnections: false
    pgAuditLog: ""
    pgAuditLogCatalog: "off"
    clientMinMessages: error
    logLinePrefix: ""
    logTimezone: ""
  ## LDAP configuration
  ## @param ldap.enabled Enable LDAP support
  ## DEPRECATED ldap.url It will removed in a future, please use 'ldap.uri' instead
  ## @param ldap.server IP address or name of the LDAP server.
  ## @param ldap.port Port number on the LDAP server to connect to
  ## @param ldap.prefix String to prepend to the user name when forming the DN to bind
  ## @param ldap.suffix String to append to the user name when forming the DN to bind
  ## DEPRECATED ldap.baseDN It will removed in a future, please use 'ldap.basedn' instead
  ## DEPRECATED ldap.bindDN It will removed in a future, please use 'ldap.binddn' instead
  ## DEPRECATED ldap.bind_password It will removed in a future, please use 'ldap.bindpw' instead
  ## @param ldap.basedn Root DN to begin the search for the user in
  ## @param ldap.binddn DN of user to bind to LDAP
  ## @param ldap.bindpw Password for the user to bind to LDAP
  ## DEPRECATED ldap.search_attr It will removed in a future, please use 'ldap.searchAttribute' instead
  ## DEPRECATED ldap.search_filter It will removed in a future, please use 'ldap.searchFilter' instead
  ## @param ldap.searchAttribute Attribute to match against the user name in the search
  ## @param ldap.searchFilter The search filter to use when doing search+bind authentication
  ## @param ldap.scheme Set to `ldaps` to use LDAPS
  ## DEPRECATED ldap.tls as string is deprecated，please use 'ldap.tls.enabled' instead
  ## @param ldap.tls.enabled Se to true to enable TLS encryption
  ##
  ldap:
    enabled: false
    server: ""
    port: ""
    prefix: ""
    suffix: ""
    basedn: ""
    binddn: ""
    bindpw: ""
    searchAttribute: ""
    searchFilter: ""
    scheme: ""
    tls:
      enabled: false
    ## @param ldap.uri LDAP URL beginning in the form `ldap[s]://host[:port]/basedn`. If provided, all the other LDAP parameters will be ignored.
    ## Ref: https://www.postgresql.org/docs/current/auth-ldap.html
    uri: ""
  ## @param postgresqlDataDir PostgreSQL data dir folder
  ##
  postgresqlDataDir: /bitnami/postgresql/data
  ## @param postgresqlSharedPreloadLibraries Shared preload libraries (comma-separated list)
  ##
  postgresqlSharedPreloadLibraries: "pgaudit"
  ## Start PostgreSQL pod(s) without limitations on shm memory.
  ## By default docker and containerd (and possibly other container runtimes) limit `/dev/shm` to `64M`
  ## ref: https://github.com/docker-library/postgres/issues/416
  ## ref: https://github.com/containerd/containerd/issues/3654
  ##
  shmVolume:
    ## @param shmVolume.enabled Enable emptyDir volume for /dev/shm for PostgreSQL pod(s)
    ##
    enabled: true
    ## @param shmVolume.sizeLimit Set this to enable a size limit on the shm tmpfs
    ## Note: the size of the tmpfs counts against container's memory limit
    ## e.g:
    ## sizeLimit: 1Gi
    ##
    sizeLimit: ""
  ## TLS configuration
  ##
  tls:
    ## @param tls.enabled Enable TLS traffic support
    ##
    enabled: false
    ## @param tls.autoGenerated Generate automatically self-signed TLS certificates
    ##
    autoGenerated: false
    ## @param tls.preferServerCiphers Whether to use the server's TLS cipher preferences rather than the client's
    ##
    preferServerCiphers: true
    ## @param tls.certificatesSecret Name of an existing secret that contains the certificates
    ##
    certificatesSecret: ""
    ## @param tls.certFilename Certificate filename
    ##
    certFilename: ""
    ## @param tls.certKeyFilename Certificate key filename
    ##
    certKeyFilename: ""
    ## @param tls.certCAFilename CA Certificate filename
    ## If provided, PostgreSQL will authenticate TLS/SSL clients by requesting them a certificate
    ## ref: https://www.postgresql.org/docs/9.6/auth-methods.html
    ##
    certCAFilename: ""
    ## @param tls.crlFilename File containing a Certificate Revocation List
    ##
    crlFilename: ""

  ## @section PostgreSQL Primary parameters
  ##
  primary:
    ## @param primary.name Name of the primary database (eg primary, master, leader, ...)
    ##
    name: primary
    ## @param primary.configuration PostgreSQL Primary main configuration to be injected as ConfigMap
    ## ref: https://www.postgresql.org/docs/current/static/runtime-config.html
    ##
    configuration: ""
    ## @param primary.pgHbaConfiguration PostgreSQL Primary client authentication configuration
    ## ref: https://www.postgresql.org/docs/current/static/auth-pg-hba-conf.html
    ## e.g:#
    ## pgHbaConfiguration: |-
    ##   local all all trust
    ##   host all all localhost trust
    ##   host mydatabase mysuser 192.168.0.0/24 md5
    ##
    pgHbaConfiguration: ""
    ## @param primary.existingConfigmap Name of an existing ConfigMap with PostgreSQL Primary configuration
    ## NOTE: `primary.configuration` and `primary.pgHbaConfiguration` will be ignored
    ##
    existingConfigmap: ""
    ## @param primary.extendedConfiguration Extended PostgreSQL Primary configuration (appended to main or default configuration)
    ## ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#allow-settings-to-be-loaded-from-files-other-than-the-default-postgresqlconf
    ##
    extendedConfiguration: ""
    ## @param primary.existingExtendedConfigmap Name of an existing ConfigMap with PostgreSQL Primary extended configuration
    ## NOTE: `primary.extendedConfiguration` will be ignored
    ##
    existingExtendedConfigmap: ""
    ## Initdb configuration
    ## ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#specifying-initdb-arguments
    ##
    initdb:
      ## @param primary.initdb.args PostgreSQL initdb extra arguments
      ##
      args: ""
      ## @param primary.initdb.postgresqlWalDir Specify a custom location for the PostgreSQL transaction log
      ##
      postgresqlWalDir: ""
      ## @param primary.initdb.scripts Dictionary of initdb scripts
      ## Specify dictionary of scripts to be run at first boot
      ## e.g:
      ## scripts:
      ##   my_init_script.sh: |
      ##      #!/bin/sh
      ##      echo "Do something."
      ##
      scripts: {}
      ## @param primary.initdb.scriptsConfigMap ConfigMap with scripts to be run at first boot
      ## NOTE: This will override `primary.initdb.scripts`
      ##
      scriptsConfigMap: ""
      ## @param primary.initdb.scriptsSecret Secret with scripts to be run at first boot (in case it contains sensitive information)
      ## NOTE: This can work along `primary.initdb.scripts` or `primary.initdb.scriptsConfigMap`
      ##
      scriptsSecret: ""
      ## @param primary.initdb.user Specify the PostgreSQL username to execute the initdb scripts
      ##
      user: ""
      ## @param primary.initdb.password Specify the PostgreSQL password to execute the initdb scripts
      ##
      password: ""
    ## Configure current cluster's primary server to be the standby server in other cluster.
    ## This will allow cross cluster replication and provide cross cluster high availability.
    ## You will need to configure pgHbaConfiguration if you want to enable this feature with local cluster replication enabled.
    ## @param primary.standby.enabled Whether to enable current cluster's primary as standby server of another cluster or not
    ## @param primary.standby.primaryHost The Host of replication primary in the other cluster
    ## @param primary.standby.primaryPort The Port of replication primary in the other cluster
    ##
    standby:
      enabled: false
      primaryHost: ""
      primaryPort: ""
    ## @param primary.extraEnvVars Array with extra environment variables to add to PostgreSQL Primary nodes
    ## e.g:
    ## extraEnvVars:
    ##   - name: FOO
    ##     value: "bar"
    ##
    extraEnvVars: []
    ## @param primary.extraEnvVarsCM Name of existing ConfigMap containing extra env vars for PostgreSQL Primary nodes
    ##
    extraEnvVarsCM: ""
    ## @param primary.extraEnvVarsSecret Name of existing Secret containing extra env vars for PostgreSQL Primary nodes
    ##
    extraEnvVarsSecret: ""
    ## @param primary.command Override default container command (useful when using custom images)
    ##
    command: []
    ## @param primary.args Override default container args (useful when using custom images)
    ##
    args: []
    ## Configure extra options for PostgreSQL Primary containers' liveness, readiness and startup probes
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
    ## @param primary.livenessProbe.enabled Enable livenessProbe on PostgreSQL Primary containers
    ## @param primary.livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
    ## @param primary.livenessProbe.periodSeconds Period seconds for livenessProbe
    ## @param primary.livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
    ## @param primary.livenessProbe.failureThreshold Failure threshold for livenessProbe
    ## @param primary.livenessProbe.successThreshold Success threshold for livenessProbe
    ##
    livenessProbe:
      enabled: true
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 6
      successThreshold: 1
    ## @param primary.readinessProbe.enabled Enable readinessProbe on PostgreSQL Primary containers
    ## @param primary.readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
    ## @param primary.readinessProbe.periodSeconds Period seconds for readinessProbe
    ## @param primary.readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
    ## @param primary.readinessProbe.failureThreshold Failure threshold for readinessProbe
    ## @param primary.readinessProbe.successThreshold Success threshold for readinessProbe
    ##
    readinessProbe:
      enabled: true
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 6
      successThreshold: 1
    ## @param primary.startupProbe.enabled Enable startupProbe on PostgreSQL Primary containers
    ## @param primary.startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
    ## @param primary.startupProbe.periodSeconds Period seconds for startupProbe
    ## @param primary.startupProbe.timeoutSeconds Timeout seconds for startupProbe
    ## @param primary.startupProbe.failureThreshold Failure threshold for startupProbe
    ## @param primary.startupProbe.successThreshold Success threshold for startupProbe
    ##
    startupProbe:
      enabled: false
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 1
      failureThreshold: 15
      successThreshold: 1
    ## @param primary.customLivenessProbe Custom livenessProbe that overrides the default one
    ##
    customLivenessProbe: {}
    ## @param primary.customReadinessProbe Custom readinessProbe that overrides the default one
    ##
    customReadinessProbe: {}
    ## @param primary.customStartupProbe Custom startupProbe that overrides the default one
    ##
    customStartupProbe: {}
    ## @param primary.lifecycleHooks for the PostgreSQL Primary container to automate configuration before or after startup
    ##
    lifecycleHooks: {}
    ## PostgreSQL Primary resource requests and limits
    ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
    ## @param primary.resources.limits The resources limits for the PostgreSQL Primary containers
    ## @param primary.resources.requests.memory The requested memory for the PostgreSQL Primary containers
    ## @param primary.resources.requests.cpu The requested cpu for the PostgreSQL Primary containers
    ##
    resources:
      limits: {}
      requests:
        memory: 256Mi
        cpu: 250m
    ## Pod Security Context
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    ## @param primary.podSecurityContext.enabled Enable security context
    ## @param primary.podSecurityContext.fsGroup Group ID for the pod
    ##
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    ## Container Security Context
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    ## @param primary.containerSecurityContext.enabled Enable container security context
    ## @param primary.containerSecurityContext.runAsUser User ID for the container
    ##
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    ## @param primary.hostAliases PostgreSQL primary pods host aliases
    ## https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
    ##
    hostAliases: []
    ## @param primary.hostNetwork Specify if host network should be enabled for PostgreSQL pod (postgresql primary)
    ##
    hostNetwork: false
    ## @param primary.hostIPC Specify if host IPC should be enabled for PostgreSQL pod (postgresql primary)
    ##
    hostIPC: false
    ## @param primary.labels Map of labels to add to the statefulset (postgresql primary)
    ##
    labels: {}
    ## @param primary.annotations Annotations for PostgreSQL primary pods
    ##
    annotations: {}
    ## @param primary.podLabels Map of labels to add to the pods (postgresql primary)
    ##
    podLabels: {}
    ## @param primary.podAnnotations Map of annotations to add to the pods (postgresql primary)
    ##
    podAnnotations: {}
    ## @param primary.podAffinityPreset PostgreSQL primary pod affinity preset. Ignored if `primary.affinity` is set. Allowed values: `soft` or `hard`
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
    ##
    podAffinityPreset: ""
    ## @param primary.podAntiAffinityPreset PostgreSQL primary pod anti-affinity preset. Ignored if `primary.affinity` is set. Allowed values: `soft` or `hard`
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
    ##
    podAntiAffinityPreset: soft
    ## PostgreSQL Primary node affinity preset
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
    ##
    nodeAffinityPreset:
      ## @param primary.nodeAffinityPreset.type PostgreSQL primary node affinity preset type. Ignored if `primary.affinity` is set. Allowed values: `soft` or `hard`
      ##
      type: ""
      ## @param primary.nodeAffinityPreset.key PostgreSQL primary node label key to match Ignored if `primary.affinity` is set.
      ## E.g.
      ## key: "kubernetes.io/e2e-az-name"
      ##
      key: ""
      ## @param primary.nodeAffinityPreset.values PostgreSQL primary node label values to match. Ignored if `primary.affinity` is set.
      ## E.g.
      ## values:
      ##   - e2e-az1
      ##   - e2e-az2
      ##
      values: []
    ## @param primary.affinity Affinity for PostgreSQL primary pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
    ## Note: primary.podAffinityPreset, primary.podAntiAffinityPreset, and primary.nodeAffinityPreset will be ignored when it's set
    ##
    affinity: {}
    ## @param primary.nodeSelector Node labels for PostgreSQL primary pods assignment
    ## ref: https://kubernetes.io/docs/user-guide/node-selection/
    ##
    nodeSelector: {}
    ## @param primary.tolerations Tolerations for PostgreSQL primary pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []
    ## @param primary.topologySpreadConstraints Topology Spread Constraints for pod assignment spread across your cluster among failure-domains. Evaluated as a template
    ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/#spread-constraints-for-pods
    ##
    topologySpreadConstraints: []
    ## @param primary.priorityClassName Priority Class to use for each pod (postgresql primary)
    ##
    priorityClassName: ""
    ## @param primary.schedulerName Use an alternate scheduler, e.g. "stork".
    ## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
    ##
    schedulerName: ""
    ## @param primary.terminationGracePeriodSeconds Seconds PostgreSQL primary pod needs to terminate gracefully
    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
    ##
    terminationGracePeriodSeconds: ""
    ## @param primary.updateStrategy.type PostgreSQL Primary statefulset strategy type
    ## @param primary.updateStrategy.rollingUpdate PostgreSQL Primary statefulset rolling update configuration parameters
    ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
    ##
    updateStrategy:
      type: RollingUpdate
      rollingUpdate: {}
    ## @param primary.extraVolumeMounts Optionally specify extra list of additional volumeMounts for the PostgreSQL Primary container(s)
    ##
    extraVolumeMounts: []
    ## @param primary.extraVolumes Optionally specify extra list of additional volumes for the PostgreSQL Primary pod(s)
    ##
    extraVolumes: []
    ## @param primary.sidecars Add additional sidecar containers to the PostgreSQL Primary pod(s)
    ## For example:
    ## sidecars:
    ##   - name: your-image-name
    ##     image: your-image
    ##     imagePullPolicy: Always
    ##     ports:
    ##       - name: portname
    ##         containerPort: 1234
    ##
    sidecars: []
    ## @param primary.initContainers Add additional init containers to the PostgreSQL Primary pod(s)
    ## Example
    ##
    ## initContainers:
    ##   - name: do-something
    ##     image: busybox
    ##     command: ['do', 'something']
    ##
    initContainers: []
    ## @param primary.extraPodSpec Optionally specify extra PodSpec for the PostgreSQL Primary pod(s)
    ##
    extraPodSpec: {}
    ## PostgreSQL Primary service configuration
    ##
    service:
      ## @param primary.service.type Kubernetes Service type
      ##
      type: ClusterIP
      ## @param primary.service.ports.postgresql PostgreSQL service port
      ##
      ports:
        postgresql: 5432
      ## Node ports to expose
      ## NOTE: choose port between <30000-32767>
      ## @param primary.service.nodePorts.postgresql Node port for PostgreSQL
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
      ##
      nodePorts:
        postgresql: ""
      ## @param primary.service.clusterIP Static clusterIP or None for headless services
      ## e.g:
      ## clusterIP: None
      ##
      clusterIP: ""
      ## @param primary.service.annotations Annotations for PostgreSQL primary service
      ##
      annotations: {}
      ## @param primary.service.loadBalancerIP Load balancer IP if service type is `LoadBalancer`
      ## Set the LoadBalancer service type to internal only
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
      ##
      loadBalancerIP: ""
      ## @param primary.service.externalTrafficPolicy Enable client source IP preservation
      ## ref https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
      ##
      externalTrafficPolicy: Cluster
      ## @param primary.service.loadBalancerSourceRanges Addresses that are allowed when service is LoadBalancer
      ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
      ##
      ## loadBalancerSourceRanges:
      ## - 10.10.10.0/24
      ##
      loadBalancerSourceRanges: []
      ## @param primary.service.extraPorts Extra ports to expose in the PostgreSQL primary service
      ##
      extraPorts: []
      ## @param primary.service.sessionAffinity Session Affinity for Kubernetes service, can be "None" or "ClientIP"
      ## If "ClientIP", consecutive client requests will be directed to the same Pod
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
      ##
      sessionAffinity: None
      ## @param primary.service.sessionAffinityConfig Additional settings for the sessionAffinity
      ## sessionAffinityConfig:
      ##   clientIP:
      ##     timeoutSeconds: 300
      ##
      sessionAffinityConfig: {}
      ## Headless service properties
      ##
      headless:
        ## @param primary.service.headless.annotations Additional custom annotations for headless PostgreSQL primary service
        ##
        annotations: {}
    ## PostgreSQL Primary persistence configuration
    ##
    persistence:
      ## @param primary.persistence.enabled Enable PostgreSQL Primary data persistence using PVC
      ##
      enabled: true
      ## @param primary.persistence.existingClaim Name of an existing PVC to use
      ##
      existingClaim: ""
      ## @param primary.persistence.mountPath The path the volume will be mounted at
      ## Note: useful when using custom PostgreSQL images
      ##
      mountPath: /bitnami/postgresql
      ## @param primary.persistence.subPath The subdirectory of the volume to mount to
      ## Useful in dev environments and one PV for multiple services
      ##
      subPath: ""
      ## @param primary.persistence.storageClass PVC Storage Class for PostgreSQL Primary data volume
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      storageClass: ""
      ## @param primary.persistence.accessModes PVC Access Mode for PostgreSQL volume
      ##
      accessModes:
        - ReadWriteOnce
      ## @param primary.persistence.size PVC Storage Request for PostgreSQL volume
      ##
      size: 8Gi
      ## @param primary.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param primary.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param primary.persistence.selector Selector to match an existing Persistent Volume (this value is evaluated as a template)
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param primary.persistence.dataSource Custom PVC data source
      ##
      dataSource: {}

  ## @section PostgreSQL read only replica parameters (only used when `architecture` is set to `replication`)
  ##
  readReplicas:
    ## @param readReplicas.name Name of the read replicas database (eg secondary, slave, ...)
    ##
    name: read
    ## @param readReplicas.replicaCount Number of PostgreSQL read only replicas
    ##
    replicaCount: 1
    ## @param readReplicas.extendedConfiguration Extended PostgreSQL read only replicas configuration (appended to main or default configuration)
    ## ref: https://github.com/bitnami/containers/tree/main/bitnami/postgresql#allow-settings-to-be-loaded-from-files-other-than-the-default-postgresqlconf
    ##
    extendedConfiguration: ""
    ## @param readReplicas.extraEnvVars Array with extra environment variables to add to PostgreSQL read only nodes
    ## e.g:
    ## extraEnvVars:
    ##   - name: FOO
    ##     value: "bar"
    ##
    extraEnvVars: []
    ## @param readReplicas.extraEnvVarsCM Name of existing ConfigMap containing extra env vars for PostgreSQL read only nodes
    ##
    extraEnvVarsCM: ""
    ## @param readReplicas.extraEnvVarsSecret Name of existing Secret containing extra env vars for PostgreSQL read only nodes
    ##
    extraEnvVarsSecret: ""
    ## @param readReplicas.command Override default container command (useful when using custom images)
    ##
    command: []
    ## @param readReplicas.args Override default container args (useful when using custom images)
    ##
    args: []
    ## Configure extra options for PostgreSQL read only containers' liveness, readiness and startup probes
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
    ## @param readReplicas.livenessProbe.enabled Enable livenessProbe on PostgreSQL read only containers
    ## @param readReplicas.livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
    ## @param readReplicas.livenessProbe.periodSeconds Period seconds for livenessProbe
    ## @param readReplicas.livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
    ## @param readReplicas.livenessProbe.failureThreshold Failure threshold for livenessProbe
    ## @param readReplicas.livenessProbe.successThreshold Success threshold for livenessProbe
    ##
    livenessProbe:
      enabled: true
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 6
      successThreshold: 1
    ## @param readReplicas.readinessProbe.enabled Enable readinessProbe on PostgreSQL read only containers
    ## @param readReplicas.readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
    ## @param readReplicas.readinessProbe.periodSeconds Period seconds for readinessProbe
    ## @param readReplicas.readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
    ## @param readReplicas.readinessProbe.failureThreshold Failure threshold for readinessProbe
    ## @param readReplicas.readinessProbe.successThreshold Success threshold for readinessProbe
    ##
    readinessProbe:
      enabled: true
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 6
      successThreshold: 1
    ## @param readReplicas.startupProbe.enabled Enable startupProbe on PostgreSQL read only containers
    ## @param readReplicas.startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
    ## @param readReplicas.startupProbe.periodSeconds Period seconds for startupProbe
    ## @param readReplicas.startupProbe.timeoutSeconds Timeout seconds for startupProbe
    ## @param readReplicas.startupProbe.failureThreshold Failure threshold for startupProbe
    ## @param readReplicas.startupProbe.successThreshold Success threshold for startupProbe
    ##
    startupProbe:
      enabled: false
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 1
      failureThreshold: 15
      successThreshold: 1
    ## @param readReplicas.customLivenessProbe Custom livenessProbe that overrides the default one
    ##
    customLivenessProbe: {}
    ## @param readReplicas.customReadinessProbe Custom readinessProbe that overrides the default one
    ##
    customReadinessProbe: {}
    ## @param readReplicas.customStartupProbe Custom startupProbe that overrides the default one
    ##
    customStartupProbe: {}
    ## @param readReplicas.lifecycleHooks for the PostgreSQL read only container to automate configuration before or after startup
    ##
    lifecycleHooks: {}
    ## PostgreSQL read only resource requests and limits
    ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
    ## @param readReplicas.resources.limits The resources limits for the PostgreSQL read only containers
    ## @param readReplicas.resources.requests.memory The requested memory for the PostgreSQL read only containers
    ## @param readReplicas.resources.requests.cpu The requested cpu for the PostgreSQL read only containers
    ##
    resources:
      limits: {}
      requests:
        memory: 256Mi
        cpu: 250m
    ## Pod Security Context
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    ## @param readReplicas.podSecurityContext.enabled Enable security context
    ## @param readReplicas.podSecurityContext.fsGroup Group ID for the pod
    ##
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    ## Container Security Context
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    ## @param readReplicas.containerSecurityContext.enabled Enable container security context
    ## @param readReplicas.containerSecurityContext.runAsUser User ID for the container
    ##
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    ## @param readReplicas.hostAliases PostgreSQL read only pods host aliases
    ## https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
    ##
    hostAliases: []
    ## @param readReplicas.hostNetwork Specify if host network should be enabled for PostgreSQL pod (PostgreSQL read only)
    ##
    hostNetwork: false
    ## @param readReplicas.hostIPC Specify if host IPC should be enabled for PostgreSQL pod (postgresql primary)
    ##
    hostIPC: false
    ## @param readReplicas.labels Map of labels to add to the statefulset (PostgreSQL read only)
    ##
    labels: {}
    ## @param readReplicas.annotations Annotations for PostgreSQL read only pods
    ##
    annotations: {}
    ## @param readReplicas.podLabels Map of labels to add to the pods (PostgreSQL read only)
    ##
    podLabels: {}
    ## @param readReplicas.podAnnotations Map of annotations to add to the pods (PostgreSQL read only)
    ##
    podAnnotations: {}
    ## @param readReplicas.podAffinityPreset PostgreSQL read only pod affinity preset. Ignored if `primary.affinity` is set. Allowed values: `soft` or `hard`
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
    ##
    podAffinityPreset: ""
    ## @param readReplicas.podAntiAffinityPreset PostgreSQL read only pod anti-affinity preset. Ignored if `primary.affinity` is set. Allowed values: `soft` or `hard`
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
    ##
    podAntiAffinityPreset: soft
    ## PostgreSQL read only node affinity preset
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
    ##
    nodeAffinityPreset:
      ## @param readReplicas.nodeAffinityPreset.type PostgreSQL read only node affinity preset type. Ignored if `primary.affinity` is set. Allowed values: `soft` or `hard`
      ##
      type: ""
      ## @param readReplicas.nodeAffinityPreset.key PostgreSQL read only node label key to match Ignored if `primary.affinity` is set.
      ## E.g.
      ## key: "kubernetes.io/e2e-az-name"
      ##
      key: ""
      ## @param readReplicas.nodeAffinityPreset.values PostgreSQL read only node label values to match. Ignored if `primary.affinity` is set.
      ## E.g.
      ## values:
      ##   - e2e-az1
      ##   - e2e-az2
      ##
      values: []
    ## @param readReplicas.affinity Affinity for PostgreSQL read only pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
    ## Note: primary.podAffinityPreset, primary.podAntiAffinityPreset, and primary.nodeAffinityPreset will be ignored when it's set
    ##
    affinity: {}
    ## @param readReplicas.nodeSelector Node labels for PostgreSQL read only pods assignment
    ## ref: https://kubernetes.io/docs/user-guide/node-selection/
    ##
    nodeSelector: {}
    ## @param readReplicas.tolerations Tolerations for PostgreSQL read only pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []
    ## @param readReplicas.topologySpreadConstraints Topology Spread Constraints for pod assignment spread across your cluster among failure-domains. Evaluated as a template
    ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/#spread-constraints-for-pods
    ##
    topologySpreadConstraints: []
    ## @param readReplicas.priorityClassName Priority Class to use for each pod (PostgreSQL read only)
    ##
    priorityClassName: ""
    ## @param readReplicas.schedulerName Use an alternate scheduler, e.g. "stork".
    ## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
    ##
    schedulerName: ""
    ## @param readReplicas.terminationGracePeriodSeconds Seconds PostgreSQL read only pod needs to terminate gracefully
    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
    ##
    terminationGracePeriodSeconds: ""
    ## @param readReplicas.updateStrategy.type PostgreSQL read only statefulset strategy type
    ## @param readReplicas.updateStrategy.rollingUpdate PostgreSQL read only statefulset rolling update configuration parameters
    ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
    ##
    updateStrategy:
      type: RollingUpdate
      rollingUpdate: {}
    ## @param readReplicas.extraVolumeMounts Optionally specify extra list of additional volumeMounts for the PostgreSQL read only container(s)
    ##
    extraVolumeMounts: []
    ## @param readReplicas.extraVolumes Optionally specify extra list of additional volumes for the PostgreSQL read only pod(s)
    ##
    extraVolumes: []
    ## @param readReplicas.sidecars Add additional sidecar containers to the PostgreSQL read only pod(s)
    ## For example:
    ## sidecars:
    ##   - name: your-image-name
    ##     image: your-image
    ##     imagePullPolicy: Always
    ##     ports:
    ##       - name: portname
    ##         containerPort: 1234
    ##
    sidecars: []
    ## @param readReplicas.initContainers Add additional init containers to the PostgreSQL read only pod(s)
    ## Example
    ##
    ## initContainers:
    ##   - name: do-something
    ##     image: busybox
    ##     command: ['do', 'something']
    ##
    initContainers: []
    ## @param readReplicas.extraPodSpec Optionally specify extra PodSpec for the PostgreSQL read only pod(s)
    ##
    extraPodSpec: {}
    ## PostgreSQL read only service configuration
    ##
    service:
      ## @param readReplicas.service.type Kubernetes Service type
      ##
      type: ClusterIP
      ## @param readReplicas.service.ports.postgresql PostgreSQL service port
      ##
      ports:
        postgresql: 5432
      ## Node ports to expose
      ## NOTE: choose port between <30000-32767>
      ## @param readReplicas.service.nodePorts.postgresql Node port for PostgreSQL
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
      ##
      nodePorts:
        postgresql: ""
      ## @param readReplicas.service.clusterIP Static clusterIP or None for headless services
      ## e.g:
      ## clusterIP: None
      ##
      clusterIP: ""
      ## @param readReplicas.service.annotations Annotations for PostgreSQL read only service
      ##
      annotations: {}
      ## @param readReplicas.service.loadBalancerIP Load balancer IP if service type is `LoadBalancer`
      ## Set the LoadBalancer service type to internal only
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
      ##
      loadBalancerIP: ""
      ## @param readReplicas.service.externalTrafficPolicy Enable client source IP preservation
      ## ref https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
      ##
      externalTrafficPolicy: Cluster
      ## @param readReplicas.service.loadBalancerSourceRanges Addresses that are allowed when service is LoadBalancer
      ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
      ##
      ## loadBalancerSourceRanges:
      ## - 10.10.10.0/24
      ##
      loadBalancerSourceRanges: []
      ## @param readReplicas.service.extraPorts Extra ports to expose in the PostgreSQL read only service
      ##
      extraPorts: []
      ## @param readReplicas.service.sessionAffinity Session Affinity for Kubernetes service, can be "None" or "ClientIP"
      ## If "ClientIP", consecutive client requests will be directed to the same Pod
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
      ##
      sessionAffinity: None
      ## @param readReplicas.service.sessionAffinityConfig Additional settings for the sessionAffinity
      ## sessionAffinityConfig:
      ##   clientIP:
      ##     timeoutSeconds: 300
      ##
      sessionAffinityConfig: {}
      ## Headless service properties
      ##
      headless:
        ## @param readReplicas.service.headless.annotations Additional custom annotations for headless PostgreSQL read only service
        ##
        annotations: {}
    ## PostgreSQL read only persistence configuration
    ##
    persistence:
      ## @param readReplicas.persistence.enabled Enable PostgreSQL read only data persistence using PVC
      ##
      enabled: true
      ## @param readReplicas.persistence.existingClaim Name of an existing PVC to use
      ##
      existingClaim: ""
      ## @param readReplicas.persistence.mountPath The path the volume will be mounted at
      ## Note: useful when using custom PostgreSQL images
      ##
      mountPath: /bitnami/postgresql
      ## @param readReplicas.persistence.subPath The subdirectory of the volume to mount to
      ## Useful in dev environments and one PV for multiple services
      ##
      subPath: ""
      ## @param readReplicas.persistence.storageClass PVC Storage Class for PostgreSQL read only data volume
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      storageClass: ""
      ## @param readReplicas.persistence.accessModes PVC Access Mode for PostgreSQL volume
      ##
      accessModes:
        - ReadWriteOnce
      ## @param readReplicas.persistence.size PVC Storage Request for PostgreSQL volume
      ##
      size: 8Gi
      ## @param readReplicas.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param readReplicas.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param readReplicas.persistence.selector Selector to match an existing Persistent Volume (this value is evaluated as a template)
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param readReplicas.persistence.dataSource Custom PVC data source
      ##
      dataSource: {}

  ## @section NetworkPolicy parameters

  ## Add networkpolicies
  ##
  networkPolicy:
    ## @param networkPolicy.enabled Enable network policies
    ##
    enabled: false
    ## @param networkPolicy.metrics.enabled Enable network policies for metrics (prometheus)
    ## @param networkPolicy.metrics.namespaceSelector [object] Monitoring namespace selector labels. These labels will be used to identify the prometheus' namespace.
    ## @param networkPolicy.metrics.podSelector [object] Monitoring pod selector labels. These labels will be used to identify the Prometheus pods.
    ##
    metrics:
      enabled: false
      ## e.g:
      ## namespaceSelector:
      ##   label: monitoring
      ##
      namespaceSelector: {}
      ## e.g:
      ## podSelector:
      ##   label: monitoring
      ##
      podSelector: {}
    ## Ingress Rules
    ##
    ingressRules:
      ## @param networkPolicy.ingressRules.primaryAccessOnlyFrom.enabled Enable ingress rule that makes PostgreSQL primary node only accessible from a particular origin.
      ## @param networkPolicy.ingressRules.primaryAccessOnlyFrom.namespaceSelector [object] Namespace selector label that is allowed to access the PostgreSQL primary node. This label will be used to identified the allowed namespace(s).
      ## @param networkPolicy.ingressRules.primaryAccessOnlyFrom.podSelector [object] Pods selector label that is allowed to access the PostgreSQL primary node. This label will be used to identified the allowed pod(s).
      ## @param networkPolicy.ingressRules.primaryAccessOnlyFrom.customRules [object] Custom network policy for the PostgreSQL primary node.
      ##
      primaryAccessOnlyFrom:
        enabled: false
        ## e.g:
        ## namespaceSelector:
        ##   label: ingress
        ##
        namespaceSelector: {}
        ## e.g:
        ## podSelector:
        ##   label: access
        ##
        podSelector: {}
        ## custom ingress rules
        ## e.g:
        ## customRules:
        ##   - from:
        ##       - namespaceSelector:
        ##           matchLabels:
        ##             label: example
        customRules: {}
      ## @param networkPolicy.ingressRules.readReplicasAccessOnlyFrom.enabled Enable ingress rule that makes PostgreSQL read-only nodes only accessible from a particular origin.
      ## @param networkPolicy.ingressRules.readReplicasAccessOnlyFrom.namespaceSelector [object] Namespace selector label that is allowed to access the PostgreSQL read-only nodes. This label will be used to identified the allowed namespace(s).
      ## @param networkPolicy.ingressRules.readReplicasAccessOnlyFrom.podSelector [object] Pods selector label that is allowed to access the PostgreSQL read-only nodes. This label will be used to identified the allowed pod(s).
      ## @param networkPolicy.ingressRules.readReplicasAccessOnlyFrom.customRules [object] Custom network policy for the PostgreSQL read-only nodes.
      ##
      readReplicasAccessOnlyFrom:
        enabled: false
        ## e.g:
        ## namespaceSelector:
        ##   label: ingress
        ##
        namespaceSelector: {}
        ## e.g:
        ## podSelector:
        ##   label: access
        ##
        podSelector: {}
        ## custom ingress rules
        ## e.g:
        ## CustomRules:
        ##   - from:
        ##       - namespaceSelector:
        ##           matchLabels:
        ##             label: example
        customRules: {}
    ## @param networkPolicy.egressRules.denyConnectionsToExternal Enable egress rule that denies outgoing traffic outside the cluster, except for DNS (port 53).
    ## @param networkPolicy.egressRules.customRules [object] Custom network policy rule
    ##
    egressRules:
      # Deny connections to external. This is not compatible with an external database.
      denyConnectionsToExternal: false
      ## Additional custom egress rules
      ## e.g:
      ## customRules:
      ##   - to:
      ##       - namespaceSelector:
      ##           matchLabels:
      ##             label: example
      customRules: {}

  ## @section Volume Permissions parameters

  ## Init containers parameters:
  ## volumePermissions: Change the owner and group of the persistent volume(s) mountpoint(s) to 'runAsUser:fsGroup' on each node
  ##
  volumePermissions:
    ## @param volumePermissions.enabled Enable init container that changes the owner and group of the persistent volume
    ##
    enabled: false
    ## @param volumePermissions.image.registry Init container volume-permissions image registry
    ## @param volumePermissions.image.repository Init container volume-permissions image repository
    ## @param volumePermissions.image.tag Init container volume-permissions image tag (immutable tags are recommended)
    ## @param volumePermissions.image.digest Init container volume-permissions image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
    ## @param volumePermissions.image.pullPolicy Init container volume-permissions image pull policy
    ## @param volumePermissions.image.pullSecrets Init container volume-permissions image pull secrets
    ##
    image:
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 11-debian-11-r76
      digest: ""
      pullPolicy: IfNotPresent
      ## Optionally specify an array of imagePullSecrets.
      ## Secrets must be manually created in the namespace.
      ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
      ## Example:
      ## pullSecrets:
      ##   - myRegistryKeySecretName
      ##
      pullSecrets: []
    ## Init container resource requests and limits
    ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
    ## @param volumePermissions.resources.limits Init container volume-permissions resource limits
    ## @param volumePermissions.resources.requests Init container volume-permissions resource requests
    ##
    resources:
      limits: {}
      requests: {}
    ## Init container' Security Context
    ## Note: the chown of the data folder is done to containerSecurityContext.runAsUser
    ## and not the below volumePermissions.containerSecurityContext.runAsUser
    ## @param volumePermissions.containerSecurityContext.runAsUser User ID for the init container
    ##
    containerSecurityContext:
      runAsUser: 0

  ## @section Other Parameters

  ## Service account for PostgreSQL to use.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  ##
  serviceAccount:
    ## @param serviceAccount.create Enable creation of ServiceAccount for PostgreSQL pod
    ##
    create: false
    ## @param serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ## Can be set to false if pods using this serviceAccount do not need to use K8s API
    ##
    automountServiceAccountToken: true
    ## @param serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}
  ## Creates role for ServiceAccount
  ## @param rbac.create Create Role and RoleBinding (required for PSP to work)
  ##
  rbac:
    create: false
    ## @param rbac.rules Custom RBAC rules to set
    ## e.g:
    ## rules:
    ##   - apiGroups:
    ##       - ""
    ##     resources:
    ##       - pods
    ##     verbs:
    ##       - get
    ##       - list
    ##
    rules: []
  ## Pod Security Policy
  ## ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
  ## @param psp.create Whether to create a PodSecurityPolicy. WARNING: PodSecurityPolicy is deprecated in Kubernetes v1.21 or later, unavailable in v1.25 or later
  ##
  psp:
    create: false

  ## @section Metrics Parameters

  metrics:
    ## @param metrics.enabled Start a prometheus exporter
    ##
    enabled: false
    ## @param metrics.image.registry PostgreSQL Prometheus Exporter image registry
    ## @param metrics.image.repository PostgreSQL Prometheus Exporter image repository
    ## @param metrics.image.tag PostgreSQL Prometheus Exporter image tag (immutable tags are recommended)
    ## @param metrics.image.digest PostgreSQL image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
    ## @param metrics.image.pullPolicy PostgreSQL Prometheus Exporter image pull policy
    ## @param metrics.image.pullSecrets Specify image pull secrets
    ##
    image:
      registry: docker.io
      repository: bitnami/postgres-exporter
      tag: 0.11.1-debian-11-r53
      digest: ""
      pullPolicy: IfNotPresent
      ## Optionally specify an array of imagePullSecrets.
      ## Secrets must be manually created in the namespace.
      ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
      ## Example:
      ## pullSecrets:
      ##   - myRegistryKeySecretName
      ##
      pullSecrets: []
    ## @param metrics.customMetrics Define additional custom metrics
    ## ref: https://github.com/wrouesnel/postgres_exporter#adding-new-metrics-via-a-config-file
    ## customMetrics:
    ##   pg_database:
    ##     query: "SELECT d.datname AS name, CASE WHEN pg_catalog.has_database_privilege(d.datname, 'CONNECT') THEN pg_catalog.pg_database_size(d.datname) ELSE 0 END AS size_bytes FROM pg_catalog.pg_database d where datname not in ('template0', 'template1', 'postgres')"
    ##     metrics:
    ##       - name:
    ##           usage: "LABEL"
    ##           description: "Name of the database"
    ##       - size_bytes:
    ##           usage: "GAUGE"
    ##           description: "Size of the database in bytes"
    ##
    customMetrics: {}
    ## @param metrics.extraEnvVars Extra environment variables to add to PostgreSQL Prometheus exporter
    ## see: https://github.com/wrouesnel/postgres_exporter#environment-variables
    ## For example:
    ##  extraEnvVars:
    ##  - name: PG_EXPORTER_DISABLE_DEFAULT_METRICS
    ##    value: "true"
    ##
    extraEnvVars: []
    ## PostgreSQL Prometheus exporter containers' Security Context
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    ## @param metrics.containerSecurityContext.enabled Enable PostgreSQL Prometheus exporter containers' Security Context
    ## @param metrics.containerSecurityContext.runAsUser Set PostgreSQL Prometheus exporter containers' Security Context runAsUser
    ## @param metrics.containerSecurityContext.runAsNonRoot Set PostgreSQL Prometheus exporter containers' Security Context runAsNonRoot
    ##
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
      runAsNonRoot: true
    ## Configure extra options for PostgreSQL Prometheus exporter containers' liveness, readiness and startup probes
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
    ## @param metrics.livenessProbe.enabled Enable livenessProbe on PostgreSQL Prometheus exporter containers
    ## @param metrics.livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
    ## @param metrics.livenessProbe.periodSeconds Period seconds for livenessProbe
    ## @param metrics.livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
    ## @param metrics.livenessProbe.failureThreshold Failure threshold for livenessProbe
    ## @param metrics.livenessProbe.successThreshold Success threshold for livenessProbe
    ##
    livenessProbe:
      enabled: true
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 6
      successThreshold: 1
    ## @param metrics.readinessProbe.enabled Enable readinessProbe on PostgreSQL Prometheus exporter containers
    ## @param metrics.readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
    ## @param metrics.readinessProbe.periodSeconds Period seconds for readinessProbe
    ## @param metrics.readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
    ## @param metrics.readinessProbe.failureThreshold Failure threshold for readinessProbe
    ## @param metrics.readinessProbe.successThreshold Success threshold for readinessProbe
    ##
    readinessProbe:
      enabled: true
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 6
      successThreshold: 1
    ## @param metrics.startupProbe.enabled Enable startupProbe on PostgreSQL Prometheus exporter containers
    ## @param metrics.startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
    ## @param metrics.startupProbe.periodSeconds Period seconds for startupProbe
    ## @param metrics.startupProbe.timeoutSeconds Timeout seconds for startupProbe
    ## @param metrics.startupProbe.failureThreshold Failure threshold for startupProbe
    ## @param metrics.startupProbe.successThreshold Success threshold for startupProbe
    ##
    startupProbe:
      enabled: false
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 1
      failureThreshold: 15
      successThreshold: 1
    ## @param metrics.customLivenessProbe Custom livenessProbe that overrides the default one
    ##
    customLivenessProbe: {}
    ## @param metrics.customReadinessProbe Custom readinessProbe that overrides the default one
    ##
    customReadinessProbe: {}
    ## @param metrics.customStartupProbe Custom startupProbe that overrides the default one
    ##
    customStartupProbe: {}
    ## @param metrics.containerPorts.metrics PostgreSQL Prometheus exporter metrics container port
    ##
    containerPorts:
      metrics: 9187
    ## PostgreSQL Prometheus exporter resource requests and limits
    ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
    ## @param metrics.resources.limits The resources limits for the PostgreSQL Prometheus exporter container
    ## @param metrics.resources.requests The requested resources for the PostgreSQL Prometheus exporter container
    ##
    resources:
      limits: {}
      requests: {}
    ## Service configuration
    ##
    service:
      ## @param metrics.service.ports.metrics PostgreSQL Prometheus Exporter service port
      ##
      ports:
        metrics: 9187
      ## @param metrics.service.clusterIP Static clusterIP or None for headless services
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#choosing-your-own-ip-address
      ##
      clusterIP: ""
      ## @param metrics.service.sessionAffinity Control where client requests go, to the same pod or round-robin
      ## Values: ClientIP or None
      ## ref: https://kubernetes.io/docs/user-guide/services/
      ##
      sessionAffinity: None
      ## @param metrics.service.annotations [object] Annotations for Prometheus to auto-discover the metrics endpoint
      ##
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "{{ .Values.metrics.service.ports.metrics }}"
    ## Prometheus Operator ServiceMonitor configuration
    ##
    serviceMonitor:
      ## @param metrics.serviceMonitor.enabled Create ServiceMonitor Resource for scraping metrics using Prometheus Operator
      ##
      enabled: false
      ## @param metrics.serviceMonitor.namespace Namespace for the ServiceMonitor Resource (defaults to the Release Namespace)
      ##
      namespace: ""
      ## @param metrics.serviceMonitor.interval Interval at which metrics should be scraped.
      ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
      ##
      interval: ""
      ## @param metrics.serviceMonitor.scrapeTimeout Timeout after which the scrape is ended
      ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
      ##
      scrapeTimeout: ""
      ## @param metrics.serviceMonitor.labels Additional labels that can be used so ServiceMonitor will be discovered by Prometheus
      ##
      labels: {}
      ## @param metrics.serviceMonitor.selector Prometheus instance selector labels
      ## ref: https://github.com/bitnami/charts/tree/main/bitnami/prometheus-operator#prometheus-configuration
      ##
      selector: {}
      ## @param metrics.serviceMonitor.relabelings RelabelConfigs to apply to samples before scraping
      ##
      relabelings: []
      ## @param metrics.serviceMonitor.metricRelabelings MetricRelabelConfigs to apply to samples before ingestion
      ##
      metricRelabelings: []
      ## @param metrics.serviceMonitor.honorLabels Specify honorLabels parameter to add the scrape endpoint
      ##
      honorLabels: false
      ## @param metrics.serviceMonitor.jobLabel The name of the label on the target service to use as the job name in prometheus.
      ##
      jobLabel: ""
    ## Custom PrometheusRule to be defined
    ## The value is evaluated as a template, so, for example, the value can depend on .Release or .Chart
    ## ref: https://github.com/coreos/prometheus-operator#customresourcedefinitions
    ##
    prometheusRule:
      ## @param metrics.prometheusRule.enabled Create a PrometheusRule for Prometheus Operator
      ##
      enabled: false
      ## @param metrics.prometheusRule.namespace Namespace for the PrometheusRule Resource (defaults to the Release Namespace)
      ##
      namespace: ""
      ## @param metrics.prometheusRule.labels Additional labels that can be used so PrometheusRule will be discovered by Prometheus
      ##
      labels: {}
      ## @param metrics.prometheusRule.rules PrometheusRule definitions
      ## Make sure to constraint the rules to the current postgresql service.
      ## rules:
      ##   - alert: HugeReplicationLag
      ##     expr: pg_replication_lag{service="{{ printf "%s-metrics" (include "common.names.fullname" .) }}"} / 3600 > 1
      ##     for: 1m
      ##     labels:
      ##       severity: critical
      ##     annotations:
      ##       description: replication for {{ include "common.names.fullname" . }} PostgreSQL is lagging by {{ "{{ $value }}" }} hour(s).
      ##       summary: PostgreSQL replication is lagging by {{ "{{ $value }}" }} hour(s).
      ##
      rules: []
  